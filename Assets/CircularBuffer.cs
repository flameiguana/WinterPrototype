//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

public class CircularBuffer<T> : IEnumerable
{

	private int Head;
	private int Tail;
	public int Count {get; private set;}

	T[] buffer;

	public CircularBuffer (int length)
	{
		Head = 0;
		Tail = 0;
		Count = 0;
		buffer = new T[length];
	}

	public bool IsEmpty()
	{
		return Count == 0;
	}

	//new elements are added to the end
	public void Add(T o)
	{
		buffer[Tail] = o;
		Tail = (Tail + 1) % buffer.Length;
		if(Count == buffer.Length){
			//push down the head, because we overwrote the oldest element
			Head = (Head + 1) % buffer.Length;
		}
		else
			++Count;
	}

	public T ReadOldest()
	{
		return buffer[Head];
	}

	//advances head
	public void DiscardOldest()
	{
		Head = (Head + 1) % buffer.Length;
		--Count;
	}
		
	public IEnumerator GetEnumerator()
	{
		int index = Head;
		int accessed = 0;
		while(accessed < Count){
			yield return buffer[index];
			index = (index + 1) % buffer.Length;
			accessed++;
		}
	}
}

